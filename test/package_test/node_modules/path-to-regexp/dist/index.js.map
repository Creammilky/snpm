{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["const DEFAULT_DELIMITER = \"/\";\nconst NOOP_VALUE = (value: string) => value;\nconst ID_CHAR = /^\\p{XID_Continue}$/u;\nconst DEBUG_URL = \"https://git.new/pathToRegexpError\";\n\n/**\n * Encode a string into another string.\n */\nexport type Encode = (value: string) => string;\n\n/**\n * Decode a string into another string.\n */\nexport type Decode = (value: string) => string;\n\nexport interface ParseOptions {\n  /**\n   * The default delimiter for segments. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * A function for encoding input strings.\n   */\n  encodePath?: Encode;\n}\n\nexport interface PathToRegexpOptions extends ParseOptions {\n  /**\n   * Regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Allow the delimiter to be arbitrarily repeated. (default: `true`)\n   */\n  loose?: boolean;\n  /**\n   * Verify patterns are valid and safe to use. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * Match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * Allow optional trailing delimiter to match. (default: `true`)\n   */\n  trailing?: boolean;\n}\n\nexport interface MatchOptions extends PathToRegexpOptions {\n  /**\n   * Function for decoding strings for params, or `false` to disable entirely. (default: `decodeURIComponent`)\n   */\n  decode?: Decode | false;\n}\n\nexport interface CompileOptions extends ParseOptions {\n  /**\n   * Regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Allow the delimiter to be arbitrarily repeated. (default: `true`)\n   */\n  loose?: boolean;\n  /**\n   * Verify patterns are valid and safe to use. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * Verifies the function is producing a valid path. (default: `true`)\n   */\n  validate?: boolean;\n  /**\n   * Function for encoding input strings for output into the path, or `false` to disable entirely. (default: `encodeURIComponent`)\n   */\n  encode?: Encode | false;\n}\n\ntype TokenType =\n  | \"{\"\n  | \"}\"\n  | \";\"\n  | \"*\"\n  | \"+\"\n  | \"?\"\n  | \"NAME\"\n  | \"PATTERN\"\n  | \"CHAR\"\n  | \"ESCAPED\"\n  | \"END\"\n  // Reserved for use.\n  | \"!\"\n  | \"@\"\n  | \",\";\n\n/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type: TokenType;\n  index: number;\n  value: string;\n}\n\nconst SIMPLE_TOKENS: Record<string, TokenType> = {\n  \"!\": \"!\",\n  \"@\": \"@\",\n  \";\": \";\",\n  \",\": \",\",\n  \"*\": \"*\",\n  \"+\": \"+\",\n  \"?\": \"?\",\n  \"{\": \"{\",\n  \"}\": \"}\",\n};\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string) {\n  const chars = [...str];\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < chars.length) {\n    const value = chars[i];\n    const type = SIMPLE_TOKENS[value];\n\n    if (type) {\n      tokens.push({ type, index: i++, value });\n      continue;\n    }\n\n    if (value === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED\", index: i++, value: chars[i++] });\n      continue;\n    }\n\n    if (value === \":\") {\n      let name = \"\";\n\n      while (ID_CHAR.test(chars[++i])) {\n        name += chars[i];\n      }\n\n      if (!name) {\n        throw new TypeError(`Missing parameter name at ${i}`);\n      }\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      continue;\n    }\n\n    if (value === \"(\") {\n      const pos = i++;\n      let count = 1;\n      let pattern = \"\";\n\n      if (chars[i] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${i}`);\n      }\n\n      while (i < chars.length) {\n        if (chars[i] === \"\\\\\") {\n          pattern += chars[i++] + chars[i++];\n          continue;\n        }\n\n        if (chars[i] === \")\") {\n          count--;\n          if (count === 0) {\n            i++;\n            break;\n          }\n        } else if (chars[i] === \"(\") {\n          count++;\n          if (chars[i + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${i}`);\n          }\n        }\n\n        pattern += chars[i++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${pos}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${pos}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: chars[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return new Iter(tokens);\n}\n\nclass Iter {\n  index = 0;\n\n  constructor(private tokens: LexToken[]) {}\n\n  peek(): LexToken {\n    return this.tokens[this.index];\n  }\n\n  tryConsume(type: LexToken[\"type\"]): string | undefined {\n    const token = this.peek();\n    if (token.type !== type) return;\n    this.index++;\n    return token.value;\n  }\n\n  consume(type: LexToken[\"type\"]): string {\n    const value = this.tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = this.peek();\n    throw new TypeError(\n      `Unexpected ${nextType} at ${index}, expected ${type}: ${DEBUG_URL}`,\n    );\n  }\n\n  text(): string {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = this.tryConsume(\"CHAR\") || this.tryConsume(\"ESCAPED\"))) {\n      result += value;\n    }\n    return result;\n  }\n\n  modifier(): string | undefined {\n    return this.tryConsume(\"?\") || this.tryConsume(\"*\") || this.tryConsume(\"+\");\n  }\n}\n\n/**\n * Tokenized path instance. Can we passed around instead of string.\n */\nexport class TokenData {\n  constructor(\n    public readonly tokens: Token[],\n    public readonly delimiter: string,\n  ) {}\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): TokenData {\n  const { encodePath = NOOP_VALUE, delimiter = encodePath(DEFAULT_DELIMITER) } =\n    options;\n  const tokens: Token[] = [];\n  const it = lexer(str);\n  let key = 0;\n\n  do {\n    const path = it.text();\n    if (path) tokens.push(encodePath(path));\n\n    const name = it.tryConsume(\"NAME\");\n    const pattern = it.tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      tokens.push({\n        name: name || String(key++),\n        pattern,\n      });\n\n      const next = it.peek();\n      if (next.type === \"*\") {\n        throw new TypeError(\n          `Unexpected * at ${next.index}, you probably want \\`/*\\` or \\`{/:foo}*\\`: ${DEBUG_URL}`,\n        );\n      }\n\n      continue;\n    }\n\n    const asterisk = it.tryConsume(\"*\");\n    if (asterisk) {\n      tokens.push({\n        name: String(key++),\n        pattern: `(?:(?!${escape(delimiter)}).)*`,\n        modifier: \"*\",\n        separator: delimiter,\n      });\n      continue;\n    }\n\n    const open = it.tryConsume(\"{\");\n    if (open) {\n      const prefix = it.text();\n      const name = it.tryConsume(\"NAME\");\n      const pattern = it.tryConsume(\"PATTERN\");\n      const suffix = it.text();\n      const separator = it.tryConsume(\";\") && it.text();\n\n      it.consume(\"}\");\n\n      const modifier = it.modifier();\n\n      tokens.push({\n        name: name || (pattern ? String(key++) : \"\"),\n        prefix: encodePath(prefix),\n        suffix: encodePath(suffix),\n        pattern,\n        modifier,\n        separator,\n      });\n      continue;\n    }\n\n    it.consume(\"END\");\n    break;\n  } while (true);\n\n  return new TokenData(tokens, delimiter);\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends ParamData = ParamData>(\n  path: Path,\n  options: CompileOptions = {},\n) {\n  const data = path instanceof TokenData ? path : parse(path, options);\n  return compileTokens<P>(data, options);\n}\n\nexport type ParamData = Partial<Record<string, string | string[]>>;\nexport type PathFunction<P extends ParamData> = (data?: P) => string;\n\n/**\n * Convert a single token into a path building function.\n */\nfunction tokenToFunction(\n  token: Token,\n  encode: Encode | false,\n): (data: ParamData) => string {\n  if (typeof token === \"string\") {\n    return () => token;\n  }\n\n  const encodeValue = encode || NOOP_VALUE;\n  const repeated = token.modifier === \"+\" || token.modifier === \"*\";\n  const optional = token.modifier === \"?\" || token.modifier === \"*\";\n  const { prefix = \"\", suffix = \"\", separator = suffix + prefix } = token;\n\n  if (encode && repeated) {\n    const stringify = (value: string, index: number) => {\n      if (typeof value !== \"string\") {\n        throw new TypeError(`Expected \"${token.name}/${index}\" to be a string`);\n      }\n      return encodeValue(value);\n    };\n\n    const compile = (value: unknown) => {\n      if (!Array.isArray(value)) {\n        throw new TypeError(`Expected \"${token.name}\" to be an array`);\n      }\n\n      if (value.length === 0) return \"\";\n\n      return prefix + value.map(stringify).join(separator) + suffix;\n    };\n\n    if (optional) {\n      return (data): string => {\n        const value = data[token.name];\n        if (value == null) return \"\";\n        return value.length ? compile(value) : \"\";\n      };\n    }\n\n    return (data): string => {\n      const value = data[token.name];\n      return compile(value);\n    };\n  }\n\n  const stringify = (value: unknown) => {\n    if (typeof value !== \"string\") {\n      throw new TypeError(`Expected \"${token.name}\" to be a string`);\n    }\n    return prefix + encodeValue(value) + suffix;\n  };\n\n  if (optional) {\n    return (data): string => {\n      const value = data[token.name];\n      if (value == null) return \"\";\n      return stringify(value);\n    };\n  }\n\n  return (data): string => {\n    const value = data[token.name];\n    return stringify(value);\n  };\n}\n\n/**\n * Transform tokens into a path building function.\n */\nfunction compileTokens<P extends ParamData>(\n  data: TokenData,\n  options: CompileOptions,\n): PathFunction<P> {\n  const {\n    encode = encodeURIComponent,\n    loose = true,\n    validate = true,\n    strict = false,\n  } = options;\n  const flags = toFlags(options);\n  const stringify = toStringify(loose, data.delimiter);\n  const sources = toRegExpSource(data, stringify, [], flags, strict);\n\n  // Compile all the tokens into regexps.\n  const encoders: Array<(data: ParamData) => string> = data.tokens.map(\n    (token, index) => {\n      const fn = tokenToFunction(token, encode);\n      if (!validate || typeof token === \"string\") return fn;\n\n      const validRe = new RegExp(`^${sources[index]}$`, flags);\n\n      return (data) => {\n        const value = fn(data);\n        if (!validRe.test(value)) {\n          throw new TypeError(\n            `Invalid value for \"${token.name}\": ${JSON.stringify(value)}`,\n          );\n        }\n        return value;\n      };\n    },\n  );\n\n  return function path(data: Record<string, any> = {}) {\n    let path = \"\";\n    for (const encoder of encoders) path += encoder(data);\n    return path;\n  };\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends ParamData> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends ParamData> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends ParamData> = (path: string) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends ParamData>(\n  path: Path,\n  options: MatchOptions = {},\n): MatchFunction<P> {\n  const { decode = decodeURIComponent, loose = true } = options;\n  const data = path instanceof TokenData ? path : parse(path, options);\n  const stringify = toStringify(loose, data.delimiter);\n  const keys: Key[] = [];\n  const re = tokensToRegexp(data, keys, options);\n\n  const decoders = keys.map((key) => {\n    if (decode && (key.modifier === \"+\" || key.modifier === \"*\")) {\n      const { prefix = \"\", suffix = \"\", separator = suffix + prefix } = key;\n      const re = new RegExp(stringify(separator), \"g\");\n      return (value: string) => value.split(re).map(decode);\n    }\n\n    return decode || NOOP_VALUE;\n  });\n\n  return function match(input: string) {\n    const m = re.exec(input);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n      const decoder = decoders[i - 1];\n      params[key.name] = decoder(m[i]);\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escape(str: string) {\n  return str.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Escape and repeat loose characters for regular expressions.\n */\nfunction looseReplacer(value: string, loose: string) {\n  const escaped = escape(value);\n  return loose ? `(?:${escaped})+(?!${escaped})` : escaped;\n}\n\n/**\n * Encode all non-delimiter characters using the encode function.\n */\nfunction toStringify(loose: boolean, delimiter: string) {\n  if (!loose) return escape;\n\n  const re = new RegExp(`(?:(?!${escape(delimiter)}).)+|(.)`, \"g\");\n  return (value: string) => value.replace(re, looseReplacer);\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction toFlags(options: { sensitive?: boolean }) {\n  return options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * A key is a capture group in the regex.\n */\nexport interface Key {\n  name: string;\n  prefix?: string;\n  suffix?: string;\n  pattern?: string;\n  modifier?: string;\n  separator?: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(\n  data: TokenData,\n  keys: Key[],\n  options: PathToRegexpOptions,\n): RegExp {\n  const {\n    trailing = true,\n    loose = true,\n    start = true,\n    end = true,\n    strict = false,\n  } = options;\n  const flags = toFlags(options);\n  const stringify = toStringify(loose, data.delimiter);\n  const sources = toRegExpSource(data, stringify, keys, flags, strict);\n  let pattern = start ? \"^\" : \"\";\n  pattern += sources.join(\"\");\n  if (trailing) pattern += `(?:${stringify(data.delimiter)})?`;\n  pattern += end ? \"$\" : `(?=${escape(data.delimiter)}|$)`;\n\n  return new RegExp(pattern, flags);\n}\n\n/**\n * Convert a token into a regexp string (re-used for path validation).\n */\nfunction toRegExpSource(\n  data: TokenData,\n  stringify: Encode,\n  keys: Key[],\n  flags: string,\n  strict: boolean,\n): string[] {\n  const defaultPattern = `(?:(?!${escape(data.delimiter)}).)+?`;\n  let backtrack = \"\";\n  let safe = true;\n\n  return data.tokens.map((token, index) => {\n    if (typeof token === \"string\") {\n      backtrack = token;\n      return stringify(token);\n    }\n\n    const {\n      prefix = \"\",\n      suffix = \"\",\n      separator = suffix + prefix,\n      modifier = \"\",\n    } = token;\n\n    const pre = stringify(prefix);\n    const post = stringify(suffix);\n\n    if (token.name) {\n      const pattern = token.pattern ? `(?:${token.pattern})` : defaultPattern;\n      const re = checkPattern(pattern, token.name, flags);\n\n      safe ||= safePattern(re, prefix || backtrack);\n      if (!safe) {\n        throw new TypeError(\n          `Ambiguous pattern for \"${token.name}\": ${DEBUG_URL}`,\n        );\n      }\n      safe = !strict || safePattern(re, suffix);\n      backtrack = \"\";\n\n      keys.push(token);\n\n      if (modifier === \"+\" || modifier === \"*\") {\n        const mod = modifier === \"*\" ? \"?\" : \"\";\n        const sep = stringify(separator);\n\n        if (!sep) {\n          throw new TypeError(\n            `Missing separator for \"${token.name}\": ${DEBUG_URL}`,\n          );\n        }\n\n        safe ||= !strict || safePattern(re, separator);\n        if (!safe) {\n          throw new TypeError(\n            `Ambiguous pattern for \"${token.name}\" separator: ${DEBUG_URL}`,\n          );\n        }\n        safe = !strict;\n\n        return `(?:${pre}(${pattern}(?:${sep}${pattern})*)${post})${mod}`;\n      }\n\n      return `(?:${pre}(${pattern})${post})${modifier}`;\n    }\n\n    return `(?:${pre}${post})${modifier}`;\n  });\n}\n\nfunction checkPattern(pattern: string, name: string, flags: string) {\n  try {\n    return new RegExp(`^${pattern}$`, flags);\n  } catch (err: any) {\n    throw new TypeError(`Invalid pattern for \"${name}\": ${err.message}`);\n  }\n}\n\nfunction safePattern(re: RegExp, value: string) {\n  return value ? !re.test(value) : false;\n}\n\n/**\n * Repeated and simple input types.\n */\nexport type Path = string | TokenData;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path: Path, options: PathToRegexpOptions = {}) {\n  const data = path instanceof TokenData ? path : parse(path, options);\n  const keys: Key[] = [];\n  const regexp = tokensToRegexp(data, keys, options);\n  return Object.assign(regexp, { keys });\n}\n"]}